\documentclass[letterpaper]{article}
\usepackage{url,multirow}
\usepackage{hyperref}
\usepackage{subscript}
\usepackage{cite}
\usepackage{graphicx}
\usepackage{colortbl, xcolor}
\usepackage{todonotes}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{comment}
\usepackage{flushend}
\usepackage{xspace}
\usepackage{booktabs}
\usepackage{mdwlist}
\usepackage{array}
\usepackage[justification=centering]{caption}

\newcolumntype{N}{>{\centering\arraybackslash}m{.7in}}
\newcolumntype{G}{>{\centering\arraybackslash}m{2in}}

\newcommand*{\boldsymbol}[1]{#1}
\newcommand\tab[1][1cm]{\hspace*{#1}}

\begin{document}

\title{title}
\author{authors}
\maketitle

\begin{abstract}
abstract
\end{abstract}

\section{Introduction}
\section{Problem statement}
\section{Our scheme}
\subsection{Architecture/pipeline}
[Matt]
\subsection{Detectors}
\subsubsection{X-Mailer header}
\tab The X-Mailer header denotes the type of software or mail client that a sender used to send the message. The value of the X-Mailer header often depends on the device used to send the message (and not just the domain part of the email address). For example, an email address with a domain part of	``gmail.com'' might have as its corresponding X-Mailer value ``iPhone Mail (12B466)''. Since the software and device used is a fundamental component of a sender's profile, it has the potential to act as sort of identity marker of a sender. As such, the detector constructed for this header relies on the consistency of the field throughout emails sent by the same sender.\\
\tab The detector's sender profile keeps track of a mapping from senders (email addresses extracted from the From header) to a list of parsed X-Mailer values. However, since email clients update versions frequently, the detector attempts to take out any version numbers. For example, the parsed value of the X-Mailer value ``iPhone Mail (12B466)'' would be ``iPhone Mail''. In addition, if no such X-Mailer header exists in the email, the sender profile will instead append the python value ``None'' to the list of X-Mailer values. With this sender profile, the detector then is able to classify emails by the following process:

\begin{enumerate}
\item Extract the email address from the From header and the parsed value from the X-Mailer value (which is ``None'' if no such X-Mailer header exists in the email's headers).
\item Look up in the sender profile the corresponding sender's list of parsed X-Mailer values.
\item If the parsed X-Mailer value of the email is in the corresponding sender's list of parsed X-Mailer values (ignoring case in comparison), the email is classified as safe.
\item Otherwise, it is classified as phishing.
\end{enumerate}

\tab In the email dataset used in the Evaluation section, it was found that 97.75\% of senders remained consistent with their X-Mailer headers over time (i.e. the list tracked in the sender profile for a given sender had only one unique value of an X-Mailer in it).  Through this classification method and consistency, the detector exploits any lack of consistency of the X-Mailer header for a given sender.  However, the effects of the detector are limiting due to the sparseness of X-Mailer headers in emails (roughly 83.56\% of emails in the dataset used in the Evaluation). Since only 16.43\% of emails have X-Mailer headers, the detector will falsely classify many emails as safe when indeed they are phishing. For this reason, the detection rate (as well as the false alarm rate) is significantly low. Thus, the detector is mostly effective when it is classifying emails from senders that send emails that generally contain X-Mailer values, where the percentage of senders that consistently send the same X-Mailer is 97.05\%.

\subsubsection{Order of headers}

\subsubsection{Received Headers}
The Received header is a trace field prepended to an email message by an SMTP server. An email can contain many Received headers, one for every STMP server it goes through. According to the received header protocol, the Received header typically has the following format:\\

Received: from x.y.test\\
\tab by example.net\\
\tab via TCP\\
\tab with ESMTP\\
\tab id ABC12345\\
\tab for <mary@example.net>;  21 Nov 1997 10:05:43 -0600\\

The Received header detector specifically uses the "from" part of the Received header, which contains a domain name and/or an IP address. With this information, we are able to construct a path of SMTP servers that the email took to get from the sender to the recipient. 

From each Received header, we first want to extract the domain name and IP address from the "from". Since there are many IP addresses that can map to SMTP servers in the same domain, we attempt to find a uniform way of finding out where this particular Received header came from. Therefore, we represent the domain names and/or IP addresses in the "from" as the CIDR blocks they are a part of. If the "from" contains an domain name, we do a WhoIs lookup on the last portion of the domain name. For example, if the domain name is "123.abc.com", we would do a WhoIs lookup on "abc.com". We use the results from the WhoIs lookup to find the CIDR block that this domain is associated with. If the "from" doesn't contain a valid domain, but has an IP address that is not private, we do a reverse DNS lookup to get the domain that this IP address maps to and then perform the same WhoIs lookup process as before. If the "from" does not have a valid domain name or a valid (public) IP address, we assign a value of "Invalid" to this Received header. If this received header does not have a "from" to begin with, we assign a value of "None" to this Received header. Using this processing method of assigning a Received header to a CIDR block, we are able to create a "path", or an ordered list of these values, for an email. 

For the sender profile of this detector, we map each sender to a list of "paths", ordered lists of CIDR blocks for each email sent by the sender. Let's say Alice sends an email to Bob. One such "path" in Bob's sender profile for Alice looks like the following: ["None", 1.2.3.4/16, "Invalid", 1.2.3.4/16, 6.7.8.9/24]. The following is the process we use when classifying an email:\\

\begin{enumerate}
\item We construct the "path" that the Received headers take, based on the process described above.
\item We process the "From" header of the email to find the associated list of paths in the sender profile.
\item We use an edit distance algorithm with a certain thresholds (0, 1, and 2) to measure the similarity of paths. For each threshold, we check to see if the path for this email is similar to a path currently in the sender profile for this sender. If a path is similar to one that is currently in the sender profile for this sender, we classify it as safe, otherwise, we classify it as phishing. This is done for each threshold. 
\end{enumerate}

There are a couple of limitations to this detector. One such limitation is the fact that not all Received headers have a "from". This results in having a "None" in the place of a CIDR block in some paths. Another limitation is that some "from" fields don't have a valid domain name or a public IP address that we could use to find the CIDR block. In this case, we have an "Invalid" in the place of a CIDR block. While our Received header detector mainly focuses on using the "from" field of the Received header, there is a lot more information that can be exploited. For example, we can analyze the "date" field and perform a similar classification as described in the Date header section of this paper.\\


TODO: Results

\subsubsection{Message-ID header}
\subsubsection{Date header}
\subsubsection{Timezone}
\subsubsection{Content-Type header}
\subsubsection{Content-Transfer-Encoding header}
\section{Evaluation}
\subsection{Personal emails}
[Michael]

\begin{table}[]
\centering
\begin{tabular}{N|N|N|N|N|N|N|}
\cline{2-7}
     & \multicolumn{2}{c|}{\textbf{1:2 Weights}} & \multicolumn{2}{c|}{\textbf{1:10 Weights}} & \multicolumn{2}{c|}{\textbf{1:100 Weights}} \\  \hline
\multicolumn{1}{|c|}{\textbf{Features}} & \textbf{False Alarm (\%)} & \textbf{Detection (\%)} & \textbf{False Alarm (\%)} & \textbf{Detection (\%)} & \textbf{False Alarm (\%)} & \textbf{Detection (\%)}  \\ \hline
\multicolumn{1}{|c|}{X-Mailer} & 0.xxx & 0.xxx & 0.xxx & 0.xxx & 0.xxx & 0.xxx  \\ \hline
\multicolumn{1}{|c|}{Received} & 0.xxx & 0.xxx  & 0.xxx & 0.xxx & 0.xxx & 0.xxx  \\ \hline
\multicolumn{1}{|c|}{Order of Headers} & 0.xxx & 0.xxx  & 0.xxx & 0.xxx & 0.xxx & 0.xxx  \\ \hline
\multicolumn{1}{|c|}{Content Type} & 0.xxx & 0.xxx  & 0.xxx & 0.xxx & 0.xxx & 0.xxx  \\ \hline
\multicolumn{1}{|c|}{Date Format} & 0.xxx & 0.xxx  & 0.xxx & 0.xxx & 0.xxx & 0.xxx  \\ \hline
\multicolumn{1}{|c|}{Message ID Domain} & 0.xxx & 0.xxx  & 0.xxx & 0.xxx & 0.xxx & 0.xxx  \\ \hline
\multicolumn{1}{|c|}{Date Timezone} & 0.xxx & 0.xxx  & 0.xxx & 0.xxx & 0.xxx & 0.xxx  \\ \hline
\end{tabular}
\caption{False Alarm and Detection Results from Varying Weights and Features}
\end{table}


\begin{table}[]
\centering
\begin{tabular}{N|N|N|N|N|N|N|}
\cline{2-7}
     & \multicolumn{2}{c|}{\textbf{1:2 Weights}} & \multicolumn{2}{c|}{\textbf{1:10 Weights}} & \multicolumn{2}{c|}{\textbf{1:100 Weights}} \\  \hline
\multicolumn{1}{|c|}{\textbf{Algorithms}} & \textbf{False Alarm (\%)} & \textbf{Detection (\%)} & \textbf{False Alarm (\%)} & \textbf{Detection (\%)} & \textbf{False Alarm (\%)} & \textbf{Detection (\%)}  \\ \hline
\multicolumn{1}{|c|}{Linear Regression} & 0.xxx & 0.xxx & 0.xxx & 0.xxx & 0.xxx & 0.xxx  \\ \hline
\multicolumn{1}{|c|}{Logistic Regression} & 0.xxx & 0.xxx  & 0.xxx & 0.xxx & 0.xxx & 0.xxx  \\ \hline
\multicolumn{1}{|c|}{Random Forest} & 0.xxx & 0.xxx  & 0.xxx & 0.xxx & 0.xxx & 0.xxx  \\ \hline
\end{tabular}
\caption{False Alarm and Detection Results from Varying Weights and Algorithms}
\end{table}
\subsection{Enterprise-scale deployment}
\section{Conclusion}

\bibliographystyle{acm}
\bibliography{bibliography}

\end{document}
